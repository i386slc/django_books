# 1.9 Включение внешних зависимостей в ваш проект

Иногда вы не можете установить внешнюю зависимость с помощью **pip** и должны включать ее непосредственно в свой проект, например, в следующих случаях:

* Когда у вас есть исправленное стороннее приложение, в котором вы сами исправили ошибку или добавили функцию, которая не была принята владельцами проекта.
* Когда вам нужно использовать частные приложения, недоступные в **индексе пакетов Python (PyPI)** или общедоступных репозиториях контроля версий.
* Когда вам нужно использовать устаревшие версии зависимостей, которые больше не доступны в **PyPI**

_Включение внешних зависимостей в ваш проект_ гарантирует, что всякий раз, когда разработчик обновляет зависимые модули, все остальные разработчики получат обновленную версию в следующем обновлении из системы контроля версий.

## Подготовка

Вы должны начать с проекта Django в виртуальной среде.

## Как это сделать...

Выполните следующие шаги один за другим для проекта виртуальной среды:

1. Если вы еще этого не сделали, создайте каталог **externals** в каталоге вашего проекта Django, **django-myproject**.
2. Затем создайте под ним каталоги **libs** и **apps**. Каталог **libs** предназначен для модулей Python, необходимых для вашего проекта, например **Boto**, **Requests**, **Twython** и **Whoosh**. Каталог **apps** предназначен для сторонних приложений **Django**, например **Django CMS**, **Django Haystack** и **django-storages**. Мы настоятельно рекомендуем вам создать файлы `README.md` в каталогах **libs** и **apps**, где вы указываете, для чего предназначен каждый модуль, какая используется версия или ревизия и откуда она взята.
3. Структура каталогов должна выглядеть примерно так:

```bash
externals/
├── apps/
│ ├── cms/
│ ├── haystack/
│ ├── storages/
│ └── README.md
└── libs/
├── boto/
├── requests/
├── twython/
└── README.md
```

4\. Следующим шагом будет размещение внешних библиотек и приложений по пути Python, чтобы они распознавались, как если бы они были установлены. Это можно сделать, добавив в настройки следующий код:

```python
# settings/_base.py
import os
import sys
BASE_DIR = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
)
EXTERNAL_BASE = os.path.join(BASE_DIR, "externals")
EXTERNAL_LIBS_PATH = os.path.join(EXTERNAL_BASE, "libs")
EXTERNAL_APPS_PATH = os.path.join(EXTERNAL_BASE, "apps")
sys.path = ["", EXTERNAL_LIBS_PATH, EXTERNAL_APPS_PATH] + sys.path
```

## Как это работает...

Модуль должен находиться под путем Python, если вы можете запустить Python и импортировать этот модуль. Один из способов поместить модуль в путь Python — изменить переменную `sys.path` перед импортом модуля, который находится в необычном месте. Значение `sys.path`, указанное в файле настроек, представляет собой список каталогов, начинающихся с пустой строки для текущего каталога, за которыми следуют каталоги в проекте и, наконец, глобально общие каталоги установки Python. Вы можете увидеть значение `sys.path` в оболочке Python следующим образом:

```python
(env)$ python manage.py shell
>>> import sys
>>> sys.path
```

При попытке импортировать модуль Python ищет модуль в этом списке и возвращает первый найденный результат.

Поэтому мы сначала определяем переменную **BASE\_DIR**, которая является абсолютным путем **django-myproject** или тремя уровнями выше, чем `myproject/settings/_base.py`. Затем мы определяем переменные **EXTERNAL\_LIBS\_PATH** и **EXTERNAL\_APPS\_PATH**, которые относятся к **BASE\_DIR**. Наконец, мы изменяем свойство `sys.path`, добавляя новые пути в начало списка. Обратите внимание, что мы также добавляем пустую строку в качестве первого пути для поиска, а это означает, что текущий каталог любого модуля всегда должен проверяться первым перед проверкой других путей Python.

Этот способ включения внешних библиотек не работает на разных платформах с пакетами Python, которые имеют привязки к языку C, например, **lxml**. Для таких зависимостей мы рекомендуем использовать требования к пункту, которые были представлены в рецепте [Обработка зависимостей проекта с помощью pip](1.-nachalo-raboty-s-django-3.0/1.5-obrabotka-zavisimostei-proekta-s-pomoshyu-pip.md).

## Смотрите также

* Рецепт [создания файловой структуры проекта](1.-nachalo-raboty-s-django-3.0/1.4-sozdanie-failovoi-struktury-proekta.md)
* Рецепт Работа с контейнерами Docker для Django, Gunicorn, Nginx и PostgreSQL
* рецепт [Обработка зависимостей проекта с помощью pip](1.-nachalo-raboty-s-django-3.0/1.5-obrabotka-zavisimostei-proekta-s-pomoshyu-pip.md)
* Рецепт [Определение относительных путей в настройках](1.-nachalo-raboty-s-django-3.0/1.7-opredelenie-otnositelnykh-putei-v-nastroikakh.md)
* Рецепт «Использование оболочки Django» в главе 10 «Bells and Whistles».

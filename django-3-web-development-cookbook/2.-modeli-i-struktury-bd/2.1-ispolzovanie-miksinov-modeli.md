# 2.1 Использование миксинов модели

В объектно-ориентированных языках, таких как Python, класс миксина можно рассматривать как **интерфейс с реализованными функциями**. Когда модель расширяет миксин, она реализует интерфейс и включает все его поля, атрибуты, свойства и методы. Миксины в моделях Django можно использовать, когда вы хотите многократно использовать общие функции в разных моделях. Примеси моделей в Django — это классы абстрактных базовых моделей. Мы рассмотрим их в следующих нескольких рецептах.

## Подготовка

Во-первых, вам нужно будет создать миксины многократного использования. Хорошее место для хранения примесей моделей — приложение `myproject.apps.core`. Если вы создаете повторно используемое приложение, которым будете делиться с другими, сохраните примеси модели в самом повторно используемом приложении, возможно, в файле **base.py**.

## Как это сделать...

Откройте файл **models.py** любого приложения Django, с которым вы хотите использовать миксины, и введите следующий код:

```python
# myproject/apps/ideas/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.models import (
    CreationModificationDateBase,
    MetaTagsBase,
    UrlBase,
)

class Idea(CreationModificationDateBase, MetaTagsBase, UrlBase):
    title = models.CharField(
        _("Title"),
        max_length=200,
    )
    content = models.TextField(
        _("Content"),
    )
    # other fields…

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title

    def get_url_path(self):
        return reverse("idea_details", kwargs={
            "idea_id": str(self.pk),
        })
```

## Как это работает...

Наследование модели Django поддерживает три типа наследования: абстрактные базовые классы, многотабличное наследование и прокси-модели. Примеси моделей — это классы абстрактных моделей, поскольку мы определяем их с помощью абстрактного метакласса **Meta** с указанными полями, свойствами и методами. Когда вы создаете такую модель, как **Idea**, как показано в предыдущем примере, она наследует все функции от **CreationModificationDateMixin**, **MetaTagsMixin** и **UrlMixin**. Все поля этих абстрактных классов сохраняются в той же таблице базы данных, что и поля расширяемой модели. В следующих рецептах вы узнаете, как определить примеси модели.

## Есть еще кое-что...

При обычном наследовании классов Python, если существует более одного базового класса, и все они реализуют определенный метод, и вы вызываете этот метод для экземпляра дочернего класса, будет вызываться только метод из первого родительского класса, как в следующем примере:

```python
>>> class A(object):
... def test(self):
...     print("A.test() called")
...
>>> class B(object):
... def test(self):
...     print("B.test() called")
...
>>> class C(object):
... def test(self):
...     print("C.test() called")
...
>>> class D(A, B, C):
... def test(self):
...     super().test()
...     print("D.test() called")
>>> d = D()
>>> d.test()
A.test() called
D.test() called
```

Это то же самое для базовых классов модели Django; однако есть одно особое исключение.

{% hint style="warning" %}
Фреймворк Django творит чудеса с метаклассами, которые вызывают методы **save()** и **delete()** из каждого из базовых классов.
{% endhint %}

Это означает, что вы можете уверенно выполнять манипуляции перед сохранением, после сохранения, перед удалением и после удаления для конкретных полей, определенных специально в миксине, путем перезаписи методов **save()** и **delete()**.

Чтобы узнать больше о различных типах наследования моделей, обратитесь к официальной документации Django, [доступной по адресу](https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance).

## Смотрите также

* Рецепт «Создание примеси модели с методами, связанными с URL»
* Рецепт создания примеси модели для обработки дат создания и изменения
* Рецепт «Создание модельного миксина для заботы о мета-тегах»
